name: Nightly Build (Windows)

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force build even if no changes since last nightly'
        type: boolean
        default: false

permissions:
  contents: write

concurrency: nightly-${{ github.workflow }}

env:
  NIGHTLY_TAG: nightly-latest

jobs:
  windows:
    name: Nightly Build (Windows)
    runs-on: windows-latest
    outputs:
      built: ${{ steps.flag.outputs.built }}
    env:
      # 署名に使う秘密情報（無ければ空文字になり、署名ステップはスキップされます）
      WINDOWS_CERT_PFX_B64: ${{ secrets.WINDOWS_CERT_PFX_B64 }}
      WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Ensure LF line endings (global)
        shell: pwsh
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      - name: Fetch tags
        shell: bash
        run: git fetch --tags --force

      - name: Check changes since last nightly
        id: diff
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.force != true)
        shell: bash
        run: |
          TAG="${{ env.NIGHTLY_TAG }}"
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            if git diff --quiet "$TAG"...HEAD -- .; then
              echo "skip=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: No changes — skip build
        if: steps.diff.outputs.skip == 'true'
        shell: pwsh
        run: echo "No changes since last nightly. Skipping."

      - name: Install SBCL (latest MSI)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/roswell/sbcl_bin/releases/latest" -Headers @{ "User-Agent" = "gh-actions" }
          $asset = $rel.assets | Where-Object { $_.name -match '\.msi$' -and $_.name -match 'windows' } | Select-Object -First 1
          if (-not $asset) { throw "SBCL MSI not found in latest release." }
          $msi = Join-Path $env:RUNNER_TEMP "sbcl.msi"
          Invoke-WebRequest $asset.browser_download_url -OutFile $msi
          Start-Process msiexec.exe -Wait -ArgumentList "/i `"$msi`" /qn /norestart"
          $sbcl = Get-Command sbcl.exe -ErrorAction SilentlyContinue
          if (-not $sbcl) {
            $sbclExe = Get-ChildItem "C:\Program Files\Steel Bank Common Lisp" -Recurse -Filter sbcl.exe -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $sbclExe) { throw "sbcl.exe not found after install." }
            $sbclExe.DirectoryName | Out-File -FilePath $env:GITHUB_PATH -Append
          }

      - name: Install Quicklisp
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          Invoke-WebRequest https://beta.quicklisp.org/quicklisp.lisp -OutFile quicklisp.lisp
          & sbcl --load quicklisp.lisp --eval "(quicklisp-quickstart:install)" --eval "(ql::without-prompting (ql:add-to-init-file))"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Resolve qlfile dependencies
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $qlfile = Join-Path $PWD "qlfile"
          $dst = Join-Path $env:USERPROFILE "common-lisp"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          if (Test-Path $qlfile) {
            Get-Content $qlfile | ForEach-Object {
              $line = $_.Trim()
              if ($line -eq "" -or $line.StartsWith("#")) { return }
              if ($line -match '^git\s+(\S+)\s+(\S+)$') {
                $name = $Matches[1]; $url = $Matches[2]
                $target = Join-Path $dst $name
                if (-not (Test-Path $target)) {
                  git -c core.autocrlf=false clone --depth 1 $url $target
                }
              }
              elseif ($line -match '^ql\s+uiop$') {
                $asdfDir = Join-Path $dst "asdf"
                if (-not (Test-Path $asdfDir)) {
                  git -c core.autocrlf=false clone --depth 1 https://gitlab.common-lisp.net/asdf/asdf.git $asdfDir
                }
                # CRLF→LF 正規化（ASDF の format ディレクティブ崩れ対策）
                Get-ChildItem -Path $asdfDir -Recurse -Include *.lisp,*.asd,*.sh | ForEach-Object {
                  (Get-Content $_.FullName -Raw).Replace("`r`n","`n") | Set-Content -NoNewline $_.FullName
                }
                bash -lc "cd '$asdfDir' && sh make-asdf.sh"
              }
            }
          } else {
            Write-Host "qlfile not found — skipping git/uiop clones."
          }

      - name: Link repo into quicklisp/local-projects
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $lp = Join-Path $env:USERPROFILE "quicklisp\local-projects"
          New-Item -ItemType Directory -Force -Path $lp | Out-Null
          cmd /c mklink /D "$lp\lem" "${{ github.workspace }}" 2>$null || robocopy "${{ github.workspace }}" "$lp\lem" /E /NFL /NDL /NJH /NJS /nc /ns /np | Out-Null

      - name: Build Lem (Windows)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          & sbcl --non-interactive `
                 --eval "(require :asdf)" `
                 --eval "(ql:quickload :lem)" `
                 --eval "(asdf:make :lem)"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      # --- ここから Defender 対策 ---

      # 署名（任意）：PFX（base64）とパスワードが指定されていれば実行
      - name: Code sign binaries (optional)
        if: steps.diff.outputs.skip != 'true' && env.WINDOWS_CERT_PFX_B64 != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:WINDOWS_CERT_PFX_B64))
          # signtool 検出
          $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue).Source
          if (-not $signtool) {
            $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            $vs = & $vswhere -latest -property installationPath
            $signtool = Get-ChildItem -Path "$vs" -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName -First 1
            if (-not $signtool) { throw "signtool.exe not found" }
          }
          $stage = Join-Path $PWD "bin"
          $targets = Get-ChildItem $stage -Recurse -Include *.exe,*.dll | ForEach-Object { $_.FullName }
          if ($targets.Count -eq 0) { throw "No binaries to sign under $stage" }
          & "$signtool" sign /fd SHA256 /td SHA256 /tr http://timestamp.digicert.com /f "$pfxPath" /p "$env:WINDOWS_CERT_PASSWORD" $targets
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      # Defender で公開前スキャン（駆除無し）
      - name: Pre-release scan with Windows Defender (no remediation)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $exe = Join-Path $PWD "bin\lem.exe"
          if (-not (Test-Path $exe)) { throw "lem.exe not found at $exe" }
          $mp = "${env:ProgramFiles}\Windows Defender\MpCmdRun.exe"
          if (-not (Test-Path $mp)) { $mp = "${env:ProgramFiles(x86)}\Windows Defender\MpCmdRun.exe" }
          if (Test-Path $mp) {
            & "$mp" -Scan -ScanType 3 -File "$exe" -DisableRemediation
            $code = $LASTEXITCODE
            # 検出の詳細を取得（検出が無ければ空）
            $det = Get-MpThreatDetection | Select-Object -Property ThreatName, Resources, InitialDetectionTime, ActionSuccess -ErrorAction SilentlyContinue
            $det | Format-List | Out-File -FilePath defender.txt
            if ($det) {
              Write-Error "Windows Defender reported detections. See defender.txt"
              exit 1
            }
          } else {
            Write-Host "MpCmdRun.exe not found; skipping Defender scan."
          }

      # --- ここまで Defender 対策 ---

      - name: Package artifacts (Windows)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $outDir = Join-Path $PWD "dist"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          $binDir = Join-Path $PWD "bin"
          if (-not (Test-Path $binDir)) { throw "bin directory not found." }
          $zip = Join-Path $outDir "lem-windows.zip"
          if (Test-Path $zip) { Remove-Item $zip -Force }
          Compress-Archive -Path (Join-Path $binDir '*') -DestinationPath $zip
          Write-Host "Packaged: $zip"

      - name: Upload artifact (Windows)
        if: steps.diff.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: lem-windows
          path: |
            dist/lem-windows.zip
            defender.txt
          if-no-files-found: warn

      - name: Flag built
        id: flag
        shell: pwsh
        run: echo "built=true" >> $env:GITHUB_OUTPUT

  publish:
    name: Publish Nightly (Windows)
    runs-on: ubuntu-latest
    needs: [windows]
    if: needs.windows.outputs.built == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Get current date
        id: date
        run: echo "date=$(date +'%Y%m%d-%H%M')" >> "$GITHUB_OUTPUT"

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: lem-windows
          path: download

      - name: Move/update nightly tag to current commit
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -f "${{ env.NIGHTLY_TAG }}"
          git push -f origin "${{ env.NIGHTLY_TAG }}"

      - name: Create/Update nightly pre-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.NIGHTLY_TAG }}
          name: Nightly Build (Windows) - ${{ steps.date.outputs.date }}
          prerelease: true
          generate_release_notes: false
          files: |
            download/lem-windows.zip
            download/defender.txt
