name: Nightly Build (Windows)

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force build even if no changes since last nightly'
        type: boolean
        default: false

permissions:
  contents: write

concurrency: nightly-windows-${{ github.workflow }}

env:
  NIGHTLY_TAG: nightly-latest

jobs:
  windows:
    name: Nightly Build (Windows)
    runs-on: windows-latest
    outputs:
      built: ${{ steps.flag.outputs.built }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        shell: bash
        run: git fetch --tags --force

      - name: Check changes since last nightly
        id: diff
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.force != true)
        shell: bash
        run: |
          TAG="${{ env.NIGHTLY_TAG }}"
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            if git diff --quiet "$TAG"...HEAD -- .; then
              echo "skip=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: No changes — skip build
        if: steps.diff.outputs.skip == 'true'
        shell: pwsh
        run: Write-Host "No changes since last nightly. Skipping."

      # 2) SBCL を最新 MSI からサイレントインストール
      - name: Install SBCL (latest MSI)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/roswell/sbcl_bin/releases/latest" -Headers @{ "User-Agent" = "gh-actions" }
          $asset = $rel.assets | Where-Object { $_.name -match '\.msi$' -and $_.name -match 'windows' } | Select-Object -First 1
          if (-not $asset) { throw "SBCL MSI not found in latest release." }
          $msi = Join-Path $env:RUNNER_TEMP "sbcl.msi"
          Invoke-WebRequest $asset.browser_download_url -OutFile $msi
          Start-Process msiexec.exe -Wait -ArgumentList "/i `"$msi`" /qn /norestart"
          $sbcl = Get-Command sbcl.exe -ErrorAction SilentlyContinue
          if (-not $sbcl) {
            $sbclExe = Get-ChildItem "C:\Program Files\Steel Bank Common Lisp" -Recurse -Filter sbcl.exe -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $sbclExe) { throw "sbcl.exe not found after install." }
            $sbclExe.DirectoryName | Out-File -FilePath $env:GITHUB_PATH -Append
          }
          sbcl --version

      # 3) qlfile を解釈し $HOME/common-lisp へ clone、ASDF は LF 正規化して make
      - name: Resolve qlfile dependencies
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $qlfile = Join-Path $PWD "qlfile"
          $dst = Join-Path $env:USERPROFILE "common-lisp"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          if (Test-Path $qlfile) {
            Get-Content $qlfile | ForEach-Object {
              $line = $_.Trim()
              if ($line -eq "" -or $line.StartsWith("#")) { return }
              if ($line -match '^git\s+(\S+)\s+(\S+)$') {
                $name = $Matches[1]; $url = $Matches[2]
                $target = Join-Path $dst $name
                if (-not (Test-Path $target)) {
                  git -c core.autocrlf=false clone --depth 1 $url $target
                }
              }
              elseif ($line -match '^ql\s+uiop$') {
                $asdfDir = Join-Path $dst "asdf"
                if (-not (Test-Path $asdfDir)) {
                  git -c core.autocrlf=false clone --depth 1 https://gitlab.common-lisp.net/asdf/asdf.git $asdfDir
                }
                # CRLF -> LF （ASDF の format ディレクティブ崩れ対策）
                Get-ChildItem -Path $asdfDir -Recurse -Include *.lisp,*.asd,*.sh | ForEach-Object {
                  (Get-Content $_.FullName -Raw).Replace("`r`n","`n") | Set-Content -NoNewline $_.FullName
                }
                bash -lc "cd '$asdfDir' && sh make-asdf.sh"
              }
            }
          } else {
            Write-Host "qlfile not found — skipping git/uiop clones."
          }

      # 4) Quicklisp を導入
      - name: Install Quicklisp
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          Invoke-WebRequest https://beta.quicklisp.org/quicklisp.lisp -OutFile quicklisp.lisp
          & sbcl --non-interactive --load quicklisp.lisp --eval "(quicklisp-quickstart:install)" --eval "(ql::without-prompting (ql:add-to-init-file))"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      # 5) このリポジトリを ASDF の探索パスに通す
      - name: Expose repo to ASDF (source-registry)
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $path = "${{ github.workspace }}".Replace('\','/')
          $expr = "(:source-registry (:tree `"$path`") :inherit-configuration)"
          echo "ASDF_SOURCE_REGISTRY=$expr" >> $env:GITHUB_ENV

      # 6) ビルド
      - name: Build Lem
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          & sbcl --non-interactive `
                 --eval "(require :asdf)" `
                 --eval "(ql:quickload :lem)" `
                 --eval "(asdf:make :lem)"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
          if (-not (Test-Path (Join-Path $PWD 'bin'))) { throw "bin directory not found after build." }

      # 7) 成果物をフォルダでステージ（zip は publish ジョブで 1 回だけ作成）
      - name: Stage artifact folder
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $outDir = Join-Path $PWD "dist\lem-windows"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          Copy-Item -Recurse -Force (Join-Path $PWD 'bin\*') $outDir

      # 8) DLL 依存関係の列挙＆欠落チェック（欠落があれば失敗）
      - name: List & verify DLL dependencies
        if: steps.diff.outputs.skip != 'true'
        shell: pwsh
        run: |
          $exe = Join-Path $PWD "dist\lem-windows\lem.exe"
          if (-not (Test-Path $exe)) { throw "lem.exe not found at $exe" }
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) { throw "vswhere.exe not found" }
          $vs = & $vswhere -latest -property installationPath
          if (-not $vs) { throw "Visual Studio installation not found" }
          $dumpbin = Get-ChildItem -Path "$vs\VC\Tools\MSVC" -Directory |
                     Sort-Object Name -Descending |
                     ForEach-Object {
                       $p = Join-Path $_.FullName "bin\Hostx64\x64\dumpbin.exe"
                       if (Test-Path $p) { $p }
                     } | Select-Object -First 1
          if (-not (Test-Path $dumpbin)) { throw "dumpbin.exe not found" }
          & $dumpbin /DEPENDENTS $exe | Tee-Object deps.txt | Out-Null
          $dlls = Select-String -Path deps.txt -Pattern '^\s+([A-Za-z0-9._-]+\.dll)\s*$' |
                  ForEach-Object { $_.Matches[0].Groups[1].Value.ToLower() } |
                  Sort-Object -Unique
          Write-Host "DEPENDENTS:`n$($dlls -join "`n")"
          $searchDirs = @(
            (Split-Path $exe -Parent),
            "$env:WINDIR\System32"
          ) + ($env:PATH -split ';' | Where-Object { $_ -and (Test-Path $_) })
          $missing = @()
          foreach ($d in $dlls) {
            $found = $false
            foreach ($dir in $searchDirs) {
              if (Test-Path (Join-Path $dir $d)) { $found = $true; break }
            }
            if (-not $found) { $missing += $d }
          }
          if ($missing.Count -gt 0) {
            Write-Error "Missing DLLs:`n$($missing -join "`n")"
            exit 1
          } else {
            Write-Host "All dependent DLLs resolved."
          }

      # 9) スモークテスト（終了コードを記録。失敗しても続行して解析材料を残す）
      - name: Smoke test (exit code + output)
        if: steps.diff.outputs.skip != 'true'
        continue-on-error: true
        shell: pwsh
        run: |
          $exe = Join-Path $PWD "dist\lem-windows\lem.exe"
          $smoke = Join-Path $env:GITHUB_WORKSPACE "smoke.txt"
          Push-Location (Split-Path $exe -Parent)
          & $exe --version 2>&1 | Tee-Object -FilePath $smoke
          $code = $LASTEXITCODE
          Pop-Location
          Write-Host "lem.exe exit code: $code"

      - name: Upload artifacts
        if: steps.diff.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: lem-windows
          path: |
            dist/lem-windows/**
            deps.txt
            smoke.txt
          if-no-files-found: error

      - name: Flag built
        id: flag
        shell: pwsh
        run: echo "built=true" >> $env:GITHUB_OUTPUT

  publish:
    name: Publish Nightly (Windows)
    runs-on: ubuntu-latest
    needs: [windows]
    if: needs.windows.outputs.built == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Get current date
        id: date
        run: echo "date=$(date +'%Y%m%d-%H%M')" >> "$GITHUB_OUTPUT"

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: lem-windows
          path: download

      - name: Create zip for release
        run: |
          cd download
          if [ -d "lem-windows" ]; then
            zip -r lem-windows.zip lem-windows
          fi

      - name: Move/update nightly tag to current commit
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -f "${{ env.NIGHTLY_TAG }}"
          git push -f origin "${{ env.NIGHTLY_TAG }}"

      - name: Create/Update nightly pre-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.NIGHTLY_TAG }}
          name: Nightly Build (Windows) - ${{ steps.date.outputs.date }}
          prerelease: true
          generate_release_notes: false
          files: |
            download/lem-windows.zip
            download/deps.txt
            download/smoke.txt
